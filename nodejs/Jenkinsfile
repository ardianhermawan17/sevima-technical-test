pipeline {
   agent {
      kubernetes {
        defaultContainer 'jnlp'
        yaml """
          apiVersion: v1
          kind: Pod
          spec:
            containers:
            - name: jnlp
              image: jenkins/inbound-agent:latest
            - name: buildkit
              image: moby/buildkit:v0.18.2
              securityContext:
                privileged: true
              command: ["/bin/sh","-c","sleep 999999"]
              tty: true
              volumeMounts:
                - name: docker-config
                  mountPath: /root/.docker
            - name: kubectl
              image: bitnami/kubectl:latest
              command: ["sleep","infinity"]
              tty: true
              securityContext:
                runAsUser: 0
                runAsGroup: 0
              volumeMounts:
                - name: workspace-volume
                  mountPath: /home/jenkins/agent
            volumes:
              - name: docker-config
                secret:
                  secretName: docker-config
              - name: workspace-volume
                emptyDir: {}
          """
      }
   }

  environment {
    REGISTRY        = 'docker.io/ardianhermawan17'
    IMAGE           = "${env.REGISTRY}/node-sevima-technical-test"
    KUBECONFIG_CRED = 'kubeconfig-jenkins'
    K8S_NAMESPACE   = 'sevima'
    DOCKER_HUB_AUTH = credentials('docker-ardian-read-write')
    LABEL_APP       = 'sevima-technical-test-node'
    DEPLOYMENT_NAME = 'sevima-technical-test-node'
    SUB_DIR         = 'nodejs'
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Verify Sub Directory') {
      steps {
        script {
          if (!fileExists("${env.SUB_DIR}")) {
            error("Sub directory '${env.SUB_DIR}' not found after checkout. Please verify repository structure.")
          }
          echo "Found sub directory at: ${env.WORKSPACE}/${env.SUB_DIR}"
        }
      }
    }

    stage('Load Secrets from Kubernetes') {
      steps {
        dir("${env.SUB_DIR}") {
          container('kubectl') {
            withKubeConfig([credentialsId: env.KUBECONFIG_CRED]) {
              sh '''
                set -eu
                SECRET_NAME=node-sevima-technical-test-env
                OUT=/tmp/node.env
                : > "$OUT"

                # list ENV
                keys="APP_NAME APP_ENV APP_DEBUG PORT DB_CONNECTION DB_HOST DB_PORT DB_DATABASE DB_USERNAME DB_PASSWORD INSTITUTION_ID"

                for k in $keys; do
                  val=$(kubectl -n ${K8S_NAMESPACE} get secret "$SECRET_NAME" -o "jsonpath={.data.${k}}" 2>/dev/null || true)
                  if [ -n "$val" ]; then
                    # decode and append
                    echo "${k}=$(echo $val | base64 -d)" >> "$OUT"
                  fi
                done

                echo "Wrote node secret partial to $OUT (if any keys found)"
              '''
            }
          }
        }
      }
    }

    stage('Setup Docker Config Secret') {
      steps {
        dir("${env.SUB_DIR}") {
          container('kubectl') {
            withCredentials([usernamePassword(credentialsId: 'docker-ardian-read-write',
                                            usernameVariable: 'DOCKER_USER',
                                            passwordVariable: 'DOCKER_PASS')]) {
              withKubeConfig([credentialsId: env.KUBECONFIG_CRED]) {
                sh '''
                  set -e

                  AUTH=$(echo -n "$DOCKER_USER:$DOCKER_PASS" | base64 | tr -d '\\n')

                  cat > config.json <<EOF
                  {
                    "auths": {
                      "https://index.docker.io/v1/": {
                        "auth": "$AUTH"
                      }
                    }
                  }
                  EOF

                  kubectl -n jenkins delete secret docker-config --ignore-not-found
                  kubectl -n jenkins create secret generic docker-config \
                    --from-file=config.json=./config.json
                '''
              }
            }
          }
        }
      }
    }

    stage('Build & Push Image with BuildKit') {
      steps {
        dir("${env.SUB_DIR}") {
          container('buildkit') {
            sh '''
              ls -la

              buildctl-daemonless.sh build \
                --frontend dockerfile.v0 \
                --local context=. \
                --local dockerfile=. \
                --output type=image,name=${IMAGE}:${BUILD_ID},push=true \
                --output type=image,name=${IMAGE}:latest,push=true \
                --opt build-arg:CI=false
            '''
          }
        }
      }
    }

    stage('Update Kubernetes Manifests') {
      steps {
        dir("${env.SUB_DIR}") {
          sh '''
            sed -i "s|docker.io/ardianhermawan17/node-sevima-technical-test:latest|${IMAGE}:${BUILD_ID}|g" deploy/k8s/deploy-node-sevima-k8s.yaml
          '''
        }
      }
    }

    stage('Deploy to kubernetes') {
      steps {
        dir("${env.SUB_DIR}") {
          container('kubectl') {
            withKubeConfig([credentialsId: env.KUBECONFIG_CRED]) {
              sh '''
                set -eu
                # Replace BUILD_ID_PLACEHOLDER with build id in template labels
                sed -i "s|BUILD_ID_PLACEHOLDER|${BUILD_ID}|g" deploy/k8s/deploy-node-sevima-k8s.yaml || true

                # Make sure image is replaced in manifest
                sed -i "s|docker.io/ardianhermawan17/node-sevima-technical-test:latest|${IMAGE}:${BUILD_ID}|g" deploy/k8s/deploy-node-sevima-k8s.yaml || true

                # Apply and capture applied names
                kubectl apply -n ${K8S_NAMESPACE} -f deploy/k8s/deploy-node-sevima-k8s.yaml -o name > ${WORKSPACE}/applied.txt
                echo "Applied:"
                cat ${WORKSPACE}/applied.txt || true
              '''
            }
          }
        }
      }
    }

    stage('Apply Ingress') {
      steps {
        dir("${env.SUB_DIR}") {
          container('kubectl') {
            withKubeConfig([credentialsId: env.KUBECONFIG_CRED]) {
              sh '''
                set -eu
                kubectl apply -n ${K8S_NAMESPACE} -f deploy/k8s/ingress-node-sevima-k8s.yaml || true
              '''
            }
          }
        }
      }
    }

    stage('Verify Deployment') {
      steps {
        dir("${env.SUB_DIR}") {
          container('kubectl') {
            withKubeConfig([credentialsId: env.KUBECONFIG_CRED]) {
              sh '''
                set -eu
                kubectl -n ${K8S_NAMESPACE} wait deployment/${DEPLOYMENT_NAME} --for=condition=available --timeout=300s
                kubectl -n ${K8S_NAMESPACE} get pods -l app=${LABEL_APP} -o wide
                kubectl -n ${K8S_NAMESPACE} rollout status deployment/${DEPLOYMENT_NAME} --timeout=300s || echo "Rollout status check timed out, but deployment may already be available"
              '''
            }
          }
        }
      }
    }
  }

  post {
    success {
      echo 'Pipeline succeeded! Deployment completed.'
    }
    failure {
      echo 'Pipeline failed! Attempting safe rollback/cleanup...'
      dir("${env.SUB_DIR}") {
        container('kubectl') {
          withKubeConfig([credentialsId: env.KUBECONFIG_CRED]) {
            sh '''
              set -eu
              APPLIED_FILE=${WORKSPACE}/applied.txt

              echo "Checking for existing deployment ${DEPLOYMENT_NAME}..."
              if kubectl -n ${K8S_NAMESPACE} get deployment ${DEPLOYMENT_NAME} >/dev/null 2>&1; then
                echo "Rolling back deployment ${DEPLOYMENT_NAME}..."
                kubectl -n ${K8S_NAMESPACE} rollout undo deployment/${DEPLOYMENT_NAME} || echo "rollout undo ok/ignored"
              else
                echo "Deployment ${DEPLOYMENT_NAME} does not exist (nothing to rollback)"
              fi

              if [ -f "$APPLIED_FILE" ]; then
                echo "Deleting applied resources listed in $APPLIED_FILE"
                while IFS= read -r r || [ -n "$r" ]; do
                  [ -z "$r" ] && continue
                  echo "Deleting resource: $r"
                  kubectl -n ${K8S_NAMESPACE} delete "$r" --ignore-not-found || echo "delete $r failed (ignored)"
                done < "$APPLIED_FILE"
              else
                echo "No applied.txt found; skipping exact-delete step."
              fi

              echo "Final check: deployments in namespace:"
              kubectl -n ${K8S_NAMESPACE} get deployments -o wide || true
            '''
          }
        }
      }
    }
    always {
      echo 'Pipeline execution completed.'
      cleanWs()
    }
  }
}